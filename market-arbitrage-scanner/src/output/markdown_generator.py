"""
Markdown report generator
Creates formatted markdown tables with scan results
"""
from typing import List
from datetime import datetime
import os
import logging

logger = logging.getLogger(__name__)


class MarkdownGenerator:
    """Generates markdown reports from scan results"""
    
    def __init__(self, output_dir: str = 'data/results'):
        """
        Initialize markdown generator
        
        Args:
            output_dir: Directory to save reports
        """
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)
    
    def generate_report(
        self,
        results: List[dict],
        filename: str = None,
        sort_by_score: bool = True
    ) -> str:
        """
        Generate markdown report from scan results
        
        Args:
            results: List of GapAnalysis results (as dicts)
            filename: Optional output filename (auto-generated if None)
            sort_by_score: Sort results by gap score descending
            
        Returns:
            Path to generated report file
        """
        if not results:
            logger.warning("No results to generate report")
            return None
        
        # Sort results
        if sort_by_score:
            results = sorted(results, key=lambda x: x.get('gap_score', 0), reverse=True)
        
        # Generate filename
        if not filename:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f'gap_analysis_{timestamp}.md'
        
        filepath = os.path.join(self.output_dir, filename)
        
        # Build markdown content
        content = self._build_markdown(results)
        
        # Write to file
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        
        logger.info(f"Report saved to: {filepath}")
        return filepath
    
    def _build_markdown(self, results: List[dict]) -> str:
        """Build markdown content from results"""
        lines = []
        
        # Title and metadata
        lines.append("# üîç Market Arbitrage Scanner - Gap Analysis Report\n")
        lines.append(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        lines.append(f"**Total Keywords Analyzed:** {len(results)}\n")
        
        # Summary statistics
        avg_gap = sum(r.get('gap_score', 0) for r in results) / len(results)
        excellent = sum(1 for r in results if r.get('gap_score', 0) >= 80)
        strong = sum(1 for r in results if 65 <= r.get('gap_score', 0) < 80)
        
        lines.append("## üìä Summary\n")
        lines.append(f"- **Average Gap Score:** {avg_gap:.1f}/100\n")
        lines.append(f"- **Excellent Opportunities (‚â•80):** {excellent}\n")
        lines.append(f"- **Strong Opportunities (65-79):** {strong}\n")
        lines.append("\n---\n")
        
        # Main results table
        lines.append("## üéØ Top Opportunities\n")
        lines.append(self._create_table(results))
        
        # Detailed breakdown for top 10
        lines.append("\n---\n")
        lines.append("## üìã Detailed Analysis (Top 10)\n")
        
        for i, result in enumerate(results[:10], 1):
            lines.append(self._create_detailed_section(i, result))
        
        # Footer
        lines.append("\n---\n")
        lines.append("*Generated by Market Arbitrage Scanner*\n")
        
        return '\n'.join(lines)
    
    def _create_table(self, results: List[dict]) -> str:
        """Create the main comparison table"""
        lines = []
        
        # Table header
        lines.append("| # | English Tool | PT-BR Translation | US Vol | BR Vol | BR Quality | Gap Score | Category |")
        lines.append("|---|-------------|------------------|--------|--------|------------|-----------|----------|")
        
        # Table rows
        for i, result in enumerate(results, 1):
            english = result.get('english_keyword', 'N/A')
            portuguese = result.get('brazilian_keyword', 'N/A')
            us_vol = result.get('us_volume_score', 0)
            br_vol = result.get('br_volume_score', 0)
            br_quality = result.get('br_avg_quality', 0)
            gap_score = result.get('gap_score', 0)
            
            # Categorize
            if gap_score >= 80:
                category = "üî• EXCELLENT"
            elif gap_score >= 65:
                category = "‚úÖ STRONG"
            elif gap_score >= 50:
                category = "‚ö†Ô∏è MODERATE"
            elif gap_score >= 35:
                category = "‚ö° WEAK"
            else:
                category = "‚ùå POOR"
            
            lines.append(
                f"| {i} | {english} | {portuguese} | "
                f"{us_vol} | {br_vol} | {br_quality:.1f} | "
                f"**{gap_score:.1f}** | {category} |"
            )
        
        return '\n'.join(lines)
    
    def _create_detailed_section(self, rank: int, result: dict) -> str:
        """Create detailed breakdown for a single result"""
        lines = []
        
        english = result.get('english_keyword', 'N/A')
        portuguese = result.get('brazilian_keyword', 'N/A')
        gap_score = result.get('gap_score', 0)
        
        lines.append(f"\n### {rank}. {english} ‚Üí {portuguese}\n")
        lines.append(f"**Gap Score:** {gap_score:.1f}/100\n")
        
        # Metrics
        lines.append("**Metrics:**")
        lines.append(f"- US Interest Score: {result.get('us_volume_score', 0)}/100")
        lines.append(f"- BR Interest Score: {result.get('br_volume_score', 0)}/100")
        lines.append(f"- BR Competitor Quality: {result.get('br_avg_quality', 0):.1f}/100\n")
        
        # Top URLs
        us_urls = result.get('us_top_urls', [])
        br_urls = result.get('br_top_urls', [])
        
        if us_urls:
            lines.append("**US Top Competitors:**")
            for i, url in enumerate(us_urls[:3], 1):
                lines.append(f"{i}. {url}")
            lines.append("")
        
        if br_urls:
            lines.append("**BR Top Competitors:**")
            for i, url in enumerate(br_urls[:3], 1):
                lines.append(f"{i}. {url}")
            lines.append("")
        else:
            lines.append("**BR Competitors:** None found (great opportunity!)\n")
        
        return '\n'.join(lines)
    
    def print_summary(self, results: List[dict]):
        """Print summary to console"""
        if not results:
            print("No results to display")
            return
        
        print("\n" + "="*80)
        print("üîç MARKET ARBITRAGE SCANNER - RESULTS SUMMARY")
        print("="*80 + "\n")
        
        # Sort by score
        sorted_results = sorted(results, key=lambda x: x.get('gap_score', 0), reverse=True)
        
        print(f"Total Keywords Analyzed: {len(results)}\n")
        
        # Top 5
        print("üèÜ TOP 5 OPPORTUNITIES:\n")
        for i, result in enumerate(sorted_results[:5], 1):
            english = result.get('english_keyword', 'N/A')
            gap_score = result.get('gap_score', 0)
            
            if gap_score >= 80:
                emoji = "üî•"
            elif gap_score >= 65:
                emoji = "‚úÖ"
            else:
                emoji = "‚ö†Ô∏è"
            
            print(f"{i}. {emoji} {english}")
            print(f"   Gap Score: {gap_score:.1f} | "
                  f"US: {result.get('us_volume_score', 0)} | "
                  f"BR: {result.get('br_volume_score', 0)} | "
                  f"Quality: {result.get('br_avg_quality', 0):.1f}\n")
        
        print("="*80)

